#!/usr/bin/env perl
use warnings;
use strict;
use File::Find qw(find);
use File::Spec::Functions qw(abs2rel rel2abs);
use Getopt::Long;
our $force = 0;
Getopt::Long::Configure(qw());
Getopt::Long::GetOptions(
    'f|force' => \$force,
) or die(":-(\n");
STDOUT->autoflush(1);
my @dirs = @ARGV;
my %found;
while (scalar @dirs >= 2) {
    cleanup(@dirs);
    shift(@dirs);
}
sub cleanup {
    my ($base_dir, @other_dirs) = @_;
    my $prefix = "$base_dir/";
    my $prefixlen = length($prefix);
    print("# finding files in $base_dir\n");
    find({
        preprocess => sub { return sort @_; }, # predictable order
        wanted => sub {
            my ($dev, $ino, $mode, $nlink) = lstat($_);
            return if !defined $dev || !defined $ino || !-f _ || $nlink < 2;
            return if substr($File::Find::name, 0, $prefixlen) ne $prefix;
            my $rel = substr($File::Find::name, $prefixlen);
            return if $found{$rel};
            $found{$rel} = 1;
            foreach my $other_dir (@other_dirs) {
                my $abs = "$other_dir/$rel";
                my ($dev2, $ino2, $mode2, $nlink2) = lstat($abs);
                next if !defined $dev2 || !defined $ino2 || $nlink2 < 2;
                next if $dev2 != $dev || $ino2 != $ino;
                if ($force) {
                    unlink($abs) or warn("unlink $abs: $!\n");
                } else {
                    printf("rm %s\n", shellquote($abs));
                }
            }
        },
        no_chdir => 1,
    }, $base_dir);
}
sub shellquote {
    my ($string) = @_;
    for ($string) {
        # stolen from String::ShellQuote to reduce dependencies
        s/'/'\\''/g;
        s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
        $_ = "'$_'";
        s/^''//;
        s/''$//;
    }
    return $string;
}
