#!/usr/bin/env perl
use warnings;
use strict;
use open qw(:locale);
use File::Find qw(find);
use File::Spec::Functions qw(abs2rel rel2abs);
use Getopt::Long;
STDOUT->autoflush(1);
STDERR->autoflush(1);
our $dry_run;
our $verbose;
Getopt::Long::Configure(qw(gnu_compat bundling no_ignore_case));
Getopt::Long::GetOptions(
    'n|dry-run' => \$dry_run,
    'v|verbose+' => \$verbose,
) or die(":-(\n");
my @dirs = @ARGV;
while (scalar @dirs >= 2) {
    cleanup(@dirs);
    shift(@dirs);
}
sub cleanup {
    my ($base_dir, @other_dirs) = @_;
    my $file_counter = 0;
    find({
        wanted => sub {
            my ($dev, $ino, $mode, $nlink) = lstat($_);
            return if !defined $dev || !defined $ino || !-f _ || $nlink < 2;
            my $rel = abs2rel($File::Find::name, $base_dir);
            my $keep = 0;
            foreach my $other_dir (@other_dirs) {
                my $abs = rel2abs($rel, $other_dir);
                my ($dev2, $ino2, $mode2, $nlink2) = lstat($abs);
                next if !defined $dev2 || !defined $ino2 || $nlink2 < 2;
                next if $dev2 != $dev || $ino2 != $ino;
                if (!$keep++) {
                    printf("## %s (%s,%s)\n", shellquote($abs), $dev, $ino);
                }
                printf("rm %s\n", shellquote($abs));
            }
        },
        no_chdir => 1,
    }, $base_dir);
}
sub shellquote {
    my ($string) = @_;
    for ($string) {
        # stolen from String::ShellQuote to reduce dependencies
        s/'/'\\''/g;
        s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
        $_ = "'$_'";
        s/^''//;
        s/''$//;
    }
    return $string;
}
