#!/usr/bin/env perl
use warnings;
use strict;
use open qw(:locale);
use File::Find qw(find);
use File::Spec::Functions qw(abs2rel rel2abs);
use Getopt::Long;
STDOUT->autoflush(1);
STDERR->autoflush(1);
our $dry_run;
our $verbose;
Getopt::Long::Configure(qw(gnu_compat bundling no_ignore_case));
Getopt::Long::GetOptions(
    'n|dry-run' => \$dry_run,
    'v|verbose+' => \$verbose,
) or die(":-(\n");
my @dirs = @ARGV;
while (scalar @dirs >= 2) {
    cleanup(@dirs);
    shift(@dirs);
}
sub cleanup {
    my ($base_dir, @other_dirs) = @_;
    my $file_counter = 0;
    find({
        wanted => sub {
            if (-t 2 && ++$file_counter % 23 == 0) {
                printf STDERR ("\r\e[K%d", $file_counter);
            }
            my ($dev, $ino, $mode, $nlink) = lstat($_);
            return if !defined $dev || !defined $ino || !-f _ || $nlink < 2;
            my $rel = abs2rel($File::Find::name, $base_dir);
            foreach my $other_dir (@other_dirs) {
                my $abs = rel2abs($rel, $other_dir);
                my ($dev2, $ino2, $mode2, $nlink2) = lstat($abs);
                next if !defined $dev2 || !defined $ino2 || $nlink2 < 2;
                next if $dev2 != $dev || $ino2 != $ino;
                if ($dry_run) {
                    clear_progress() if -t 2;
                    print("[DRY RUN]: rm $abs\n");
                } else {
                    if (!unlink($abs)) {
                        clear_progress() if -t 2;
                        warn("rm $abs: $!\n");
                    } elsif ($verbose) {
                        clear_progress() if -t 2;
                        warn("removed $abs\n");
                    }
                }
            }
        },
        no_chdir => 1,
    }, $base_dir);
    clear_progress() if -t 2;
}
sub clear_progress {
    print STDERR ("\r\e[K") if -t 2;
}
