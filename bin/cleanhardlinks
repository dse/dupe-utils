#!/usr/bin/env perl
use warnings;
use strict;
use open qw(:locale);
use File::Find qw(find);
use File::Spec::Functions qw(abs2rel rel2abs);
use Getopt::Long;
STDOUT->autoflush(1);
our $dry_run;
our $verbose;
Getopt::Long::Configure(qw(gnu_compat bundling no_ignore_case));
Getopt::Long::GetOptions(
    'n|dry-run' => \$dry_run,
    'v|verbose+' => \$verbose,
) or die(":-(\n");
my @dirs = @ARGV;
while (scalar @dirs >= 2) {
    cleanup(@dirs);
    shift(@dirs);
}
sub cleanup {
    my ($base_dir, @other_dirs) = @_;
    find({
        wanted => sub {
            my ($dev, $ino, $mode, $nlink) = lstat($_);
            return if !defined $dev || !defined $ino || !-f _ || $nlink < 2;
            my $rel = abs2rel($File::Find::name, $base_dir);
            foreach my $other_dir (@other_dirs) {
                my $abs = rel2abs($rel, $other_dir);
                my ($dev2, $ino2, $mode2, $nlink2) = lstat($abs);
                next if !defined $dev2 || !defined $ino2 || $nlink2 < 2;
                next if $dev2 != $dev || $ino2 != $ino;
                if ($dry_run) {
                    print("[DRY RUN]: rm $abs\n");
                } else {
                    if (!unlink($abs)) {
                        warn("rm $abs: $!\n");
                    } elsif ($verbose) {
                        warn("removed $abs\n");
                    }
                }
            }
        },
        no_chdir => 1,
    }, $base_dir);
}
