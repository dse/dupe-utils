#!/usr/bin/env perl
## no critic (ProhibitInteractiveTest)
use warnings;
use strict;

# dedupe by FILE CONTENTS

use Getopt::Long;

use FindBin;
use lib "${FindBin::Bin}/../lib";
use My::DupeGroup qw(group_dupes);
use My::ShellQuote qw(shell_quote);
use My::GetFileInfo qw(get_file_info);

use constant ASCENDING => 1;
use constant DESCENDING => -1;

our $force    = 0;
our $verbose  = 0;
our $progress = 0;
our $sort     = 0;
our $dry_run  = 0;
our $order    = ASCENDING;
Getopt::Long::Configure(qw(gnu_getopt no_ignore_case));
Getopt::Long::GetOptions(
    'f|force'    => sub { $dry_run = 0; $force = 1; },
    'v|verbose+' => \$verbose,
    'p|progress' => \$progress,
    's|sort'     => \$sort,
    'n|dry-run'  => sub { $dry_run = 1; $force = 0; },
    'asc|ascending'   => sub { $order = ASCENDING; },
    'desc|descending' => sub { $order = DESCENDING; },
) or die(":-(\n");
if (!$force && !$dry_run) {
    die("either -f/--force or -n/--dry-run must be specified\n");
}

$progress &&= -t 2;

# Group filenames of the same inode, so we only read from one of those
# filenames ever.  An "inode" here is an inode's number preceded by
# its device number, uniqifying inodes across filesystems.
my %links_by_size_inode;
my $sub = sub {
    my ($dev, $ino, $size, $mtime, $pathname) = @_;
    my $inode = "$dev,$ino";
    push(@{$links_by_size_inode{$size}{$inode}}, $pathname);
};

# Read from stdin and/or files and/or traverse directories.
get_file_info({ sub => $sub }, @ARGV);

my @size;
if ($order == ASCENDING) {
    # remove small duplicates first
    @size = sort { $a <=> $b } keys %links_by_size_inode;
} elsif ($order == DESCENDING) {
    # remove large duplicates first
    @size = sort { $b <=> $a } keys %links_by_size_inode;
} else {
    die("UNEXPECTED: order must be ascending or descending");
}

foreach my $size (@size) {
    my @inodes = keys %{$links_by_size_inode{$size}};
    next if scalar @inodes < 2;
    my @filenames_to_read = sort map { $links_by_size_inode{$size}->{$_}->[0] } @inodes;
    my %inodes_by_filename;
    my %links_by_inode;
    foreach my $inode (@inodes) {
        $links_by_inode{$inode} = $links_by_size_inode{$size}{$inode};
        foreach my $filename (@{$links_by_size_inode{$size}{$inode}}) {
            $inodes_by_filename{$filename} = $inode;
        }
    }
    my @duplicate_groups = group_dupes(@filenames_to_read); # the dirty work
    foreach my $duplicate_group (sort { $a->[0] cmp $b->[0] } @duplicate_groups) {
        my ($file_to_keep, @files_to_delete) = sort @$duplicate_group;
        if ($dry_run) {
            my $inode_to_keep = $inodes_by_filename{$file_to_keep};
            my @files_to_keep = @{$links_by_inode{$inode_to_keep}};
            foreach my $file_to_keep (@files_to_keep) {
                printf("# keep %s # %s\n", $file_to_keep, $inode_to_keep);
            }
        }
        foreach my $file_to_delete (@files_to_delete) {
            my $inode_to_delete = $inodes_by_filename{$file_to_delete};
            my @links_to_delete = sort @{$links_by_inode{$inode_to_delete}};
            foreach my $link_to_delete (@links_to_delete) {
                if ($force) {
                    if (!unlink($link_to_delete)) {
                        warn("$link_to_delete: $!\n");
                    } else {
                        warn("rm $link_to_delete\n") if $verbose;
                    }
                }
                if ($dry_run) {
                    printf("rm %s # %s\n", shell_quote($link_to_delete), $inode_to_delete);
                }
            }
        }
    }
}
